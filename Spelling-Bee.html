<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Canvas with OCR</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #canvasContainer {
            position: relative;
            max-width: 90%;
        }
        canvas {
            border: 2px solid black;
            background-color: white;
            width: 100%;
            height: auto;
        }
        #toolbar {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        #output {
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
        }
        .toolbar-item {
            margin-bottom: 5px;
        }
        button, input[type="color"], input[type="range"] {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover, input[type="color"]:hover, input[type="range"]:hover {
            background-color: #f0f0f0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        @media (max-width: 768px) {
            #toolbar {
                flex-direction: row;
                bottom: 10px;
                top: auto;
                width: calc(100% - 20px);
                justify-content: space-around;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="drawingCanvas" width="800" height="600"></canvas>
        <div id="toolbar">
            <button id="clearCanvas" class="toolbar-item">Clear Canvas</button>
            <label class="toolbar-item">Brush Color:
                <input type="color" id="brushColor">
            </label>
            <label class="toolbar-item">Brush Width:
                <input type="range" id="brushWidth" min="1" max="20" value="5">
            </label>
        </div>
    </div>
    <div id="output"></div>

    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.4/dist/tesseract.min.js"></script>
    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const clearCanvasButton = document.getElementById('clearCanvas');
        const brushColorInput = document.getElementById('brushColor');
        const brushWidthInput = document.getElementById('brushWidth');
        let drawing = false;
        let idleTimer;

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchstart', startDrawingTouch);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchmove', drawTouch);
        clearCanvasButton.addEventListener('click', clearCanvas);

        function startDrawing(e) {
            drawing = true;
            draw(e);
        }

        function startDrawingTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent("mousedown", {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function stopDrawing() {
            drawing = false;
            ctx.beginPath();
            resetIdleTimer();
        }

        function draw(e) {
            if (!drawing) return;

            ctx.lineWidth = brushWidthInput.value;
            ctx.lineCap = 'round';
            ctx.strokeStyle = brushColorInput.value || 'black';

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            ctx.lineTo((e.clientX - rect.left) * scaleX, (e.clientY - rect.top) * scaleY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo((e.clientX - rect.left) * scaleX, (e.clientY - rect.top) * scaleY);
            resetIdleTimer();
        }

        function drawTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent("mousemove", {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function resetIdleTimer() {
            if (idleTimer) clearTimeout(idleTimer);
            idleTimer = setTimeout(convertToText, 3000);
        }

        function convertToText() {
            const imageData = canvas.toDataURL();
            Tesseract.recognize(
                imageData,
                'eng',
                {
                    logger: m => console.log(m)
                }
            ).then(({ data: { text } }) => {
                const upperCaseText = text.toUpperCase().trim();
                alert(`Converted drawing to text: ${upperCaseText}`);
                checkOnlineDictionary(upperCaseText);
            }).catch(err => {
                console.error(err);
                alert('Error recognizing text.');
            });
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        async function checkOnlineDictionary(word) {
            const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.title === "No Definitions Found") {
                    alert('No match found in the dictionary.');
                } else {
                    const meaning = data[0].meanings[0].definitions[0].definition;
                    showCongratsMessage(word, meaning);
                }
            } catch (error) {
                console.error('Error fetching dictionary data:', error);
                alert('Error fetching dictionary data.');
            }
        }

        function showCongratsMessage(word, meaning) {
            alert(`Congratulations! The word "${word}" matches. Meaning: ${meaning}`);
        }

        // Initially fill canvas with white background
        clearCanvas();
    </script>
</body>
</html>
